{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, Inject, EventEmitter, Directive, Input, Output, NgModule } from '@angular/core';\nimport { BehaviorSubject, of, from, merge, forkJoin } from 'rxjs';\nimport { map, switchMap, catchError, mergeAll, first, mergeMap, every, skip, take, tap } from 'rxjs/operators';\nimport * as i3 from '@angular/router';\nconst NgxPermissionsPredefinedStrategies = {\n  REMOVE: 'remove',\n  SHOW: 'show'\n};\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\nfunction isPlainObject(value) {\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    return false;\n  } else {\n    const prototype = Object.getPrototypeOf(value);\n    return prototype === null || prototype === Object.prototype;\n  }\n}\n\nfunction isString(value) {\n  return !!value && typeof value === 'string';\n}\n\nfunction isBoolean(value) {\n  return typeof value === 'boolean';\n}\n\nfunction isPromise(promise) {\n  return Object.prototype.toString.call(promise) === '[object Promise]';\n}\n\nfunction notEmptyValue(value) {\n  if (Array.isArray(value)) {\n    return value.length > 0;\n  }\n\n  return !!value;\n}\n\nfunction transformStringToArray(value) {\n  if (isString(value)) {\n    return [value];\n  }\n\n  return value;\n}\n\nclass NgxPermissionsStore {\n  constructor() {\n    this.permissionsSource = new BehaviorSubject({});\n    this.permissions$ = this.permissionsSource.asObservable();\n  }\n\n}\n\nNgxPermissionsStore.ɵfac = function NgxPermissionsStore_Factory(t) {\n  return new (t || NgxPermissionsStore)();\n};\n\nNgxPermissionsStore.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxPermissionsStore,\n  factory: NgxPermissionsStore.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsStore, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n\nconst USE_PERMISSIONS_STORE = new InjectionToken('USE_PERMISSIONS_STORE');\n\nclass NgxPermissionsService {\n  constructor(isolate = false, permissionsStore) {\n    this.isolate = isolate;\n    this.permissionsStore = permissionsStore;\n    this.permissionsSource = isolate ? new BehaviorSubject({}) : permissionsStore.permissionsSource;\n    this.permissions$ = this.permissionsSource.asObservable();\n  }\n  /**\n   * Remove all permissions from permissions source\n   */\n\n\n  flushPermissions() {\n    this.permissionsSource.next({});\n  }\n\n  hasPermission(permission) {\n    if (!permission || Array.isArray(permission) && permission.length === 0) {\n      return Promise.resolve(true);\n    }\n\n    permission = transformStringToArray(permission);\n    return this.hasArrayPermission(permission);\n  }\n\n  loadPermissions(permissions, validationFunction) {\n    const newPermissions = permissions.reduce((source, name) => this.reducePermission(source, name, validationFunction), {});\n    this.permissionsSource.next(newPermissions);\n  }\n\n  addPermission(permission, validationFunction) {\n    if (Array.isArray(permission)) {\n      const permissions = permission.reduce((source, name) => this.reducePermission(source, name, validationFunction), this.permissionsSource.value);\n      this.permissionsSource.next(permissions);\n    } else {\n      const permissions = this.reducePermission(this.permissionsSource.value, permission, validationFunction);\n      this.permissionsSource.next(permissions);\n    }\n  }\n\n  removePermission(permissionName) {\n    const permissions = Object.assign({}, this.permissionsSource.value);\n    delete permissions[permissionName];\n    this.permissionsSource.next(permissions);\n  }\n\n  getPermission(name) {\n    return this.permissionsSource.value[name];\n  }\n\n  getPermissions() {\n    return this.permissionsSource.value;\n  }\n\n  reducePermission(source, name, validationFunction) {\n    if (!!validationFunction && isFunction(validationFunction)) {\n      return Object.assign(Object.assign({}, source), {\n        [name]: {\n          name,\n          validationFunction\n        }\n      });\n    }\n\n    return Object.assign(Object.assign({}, source), {\n      [name]: {\n        name\n      }\n    });\n  }\n\n  hasArrayPermission(permissions) {\n    const promises = permissions.map(key => {\n      if (this.hasPermissionValidationFunction(key)) {\n        const validationFunction = this.permissionsSource.value[key].validationFunction;\n        const immutableValue = Object.assign({}, this.permissionsSource.value);\n        return of(null).pipe(map(() => validationFunction(key, immutableValue)), switchMap(promise => isBoolean(promise) ? of(promise) : promise), catchError(() => of(false)));\n      } // check for name of the permission if there is no validation function\n\n\n      return of(!!this.permissionsSource.value[key]);\n    });\n    return from(promises).pipe(mergeAll(), first(data => data !== false, false), map(data => data !== false)).toPromise().then(data => data);\n  }\n\n  hasPermissionValidationFunction(key) {\n    return !!this.permissionsSource.value[key] && !!this.permissionsSource.value[key].validationFunction && isFunction(this.permissionsSource.value[key].validationFunction);\n  }\n\n}\n\nNgxPermissionsService.ɵfac = function NgxPermissionsService_Factory(t) {\n  return new (t || NgxPermissionsService)(i0.ɵɵinject(USE_PERMISSIONS_STORE), i0.ɵɵinject(NgxPermissionsStore));\n};\n\nNgxPermissionsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxPermissionsService,\n  factory: NgxPermissionsService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [USE_PERMISSIONS_STORE]\n      }]\n    }, {\n      type: NgxPermissionsStore\n    }];\n  }, null);\n})();\n\nclass NgxPermissionsConfigurationStore {\n  constructor() {\n    this.strategiesSource = new BehaviorSubject({});\n    this.strategies$ = this.strategiesSource.asObservable();\n  }\n\n}\n\nNgxPermissionsConfigurationStore.ɵfac = function NgxPermissionsConfigurationStore_Factory(t) {\n  return new (t || NgxPermissionsConfigurationStore)();\n};\n\nNgxPermissionsConfigurationStore.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxPermissionsConfigurationStore,\n  factory: NgxPermissionsConfigurationStore.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsConfigurationStore, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n\nconst USE_CONFIGURATION_STORE = new InjectionToken('USE_CONFIGURATION_STORE');\n\nclass NgxPermissionsConfigurationService {\n  constructor(isolate = false, configurationStore) {\n    this.isolate = isolate;\n    this.configurationStore = configurationStore;\n    this.strategiesSource = this.isolate ? new BehaviorSubject({}) : this.configurationStore.strategiesSource;\n    this.strategies$ = this.strategiesSource.asObservable();\n    this.onAuthorisedDefaultStrategy = this.isolate ? undefined : this.configurationStore.onAuthorisedDefaultStrategy;\n    this.onUnAuthorisedDefaultStrategy = this.isolate ? undefined : this.configurationStore.onUnAuthorisedDefaultStrategy;\n  }\n\n  setDefaultOnAuthorizedStrategy(name) {\n    if (this.isolate) {\n      this.onAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n    } else {\n      this.configurationStore.onAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n      this.onAuthorisedDefaultStrategy = this.configurationStore.onAuthorisedDefaultStrategy;\n    }\n  }\n\n  setDefaultOnUnauthorizedStrategy(name) {\n    if (this.isolate) {\n      this.onUnAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n    } else {\n      this.configurationStore.onUnAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n      this.onUnAuthorisedDefaultStrategy = this.configurationStore.onUnAuthorisedDefaultStrategy;\n    }\n  }\n\n  addPermissionStrategy(key, func) {\n    this.strategiesSource.value[key] = func;\n  }\n\n  getStrategy(key) {\n    return this.strategiesSource.value[key];\n  }\n\n  getAllStrategies() {\n    return this.strategiesSource.value;\n  }\n\n  getDefinedStrategy(name) {\n    if (this.strategiesSource.value[name] || this.isPredefinedStrategy(name)) {\n      return name;\n    } else {\n      throw new Error(`No ' ${name} ' strategy is found please define one`);\n    }\n  }\n\n  isPredefinedStrategy(strategy) {\n    return strategy === NgxPermissionsPredefinedStrategies.SHOW || strategy === NgxPermissionsPredefinedStrategies.REMOVE;\n  }\n\n}\n\nNgxPermissionsConfigurationService.ɵfac = function NgxPermissionsConfigurationService_Factory(t) {\n  return new (t || NgxPermissionsConfigurationService)(i0.ɵɵinject(USE_CONFIGURATION_STORE), i0.ɵɵinject(NgxPermissionsConfigurationStore));\n};\n\nNgxPermissionsConfigurationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxPermissionsConfigurationService,\n  factory: NgxPermissionsConfigurationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsConfigurationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [USE_CONFIGURATION_STORE]\n      }]\n    }, {\n      type: NgxPermissionsConfigurationStore\n    }];\n  }, null);\n})();\n\nclass NgxRolesStore {\n  constructor() {\n    this.rolesSource = new BehaviorSubject({});\n    this.roles$ = this.rolesSource.asObservable();\n  }\n\n}\n\nconst USE_ROLES_STORE = new InjectionToken('USE_ROLES_STORE');\n\nclass NgxRolesService {\n  constructor(isolate = false, rolesStore, permissionsService) {\n    this.isolate = isolate;\n    this.rolesStore = rolesStore;\n    this.permissionsService = permissionsService;\n    this.rolesSource = this.isolate ? new BehaviorSubject({}) : this.rolesStore.rolesSource;\n    this.roles$ = this.rolesSource.asObservable();\n  }\n\n  addRole(name, validationFunction) {\n    const roles = Object.assign(Object.assign({}, this.rolesSource.value), {\n      [name]: {\n        name,\n        validationFunction\n      }\n    });\n    this.rolesSource.next(roles);\n  }\n\n  addRoleWithPermissions(name, permissions) {\n    this.permissionsService.addPermission(permissions);\n    this.addRole(name, permissions);\n  }\n\n  addRoles(rolesObj) {\n    Object.keys(rolesObj).forEach((key, index) => {\n      this.addRole(key, rolesObj[key]);\n    });\n  }\n\n  addRolesWithPermissions(rolesObj) {\n    Object.keys(rolesObj).forEach((key, index) => {\n      this.addRoleWithPermissions(key, rolesObj[key]);\n    });\n  }\n\n  flushRoles() {\n    this.rolesSource.next({});\n  }\n\n  flushRolesAndPermissions() {\n    this.flushRoles();\n    this.permissionsService.flushPermissions();\n  }\n\n  removeRole(roleName) {\n    const roles = Object.assign({}, this.rolesSource.value);\n    delete roles[roleName];\n    this.rolesSource.next(roles);\n  }\n\n  getRoles() {\n    return this.rolesSource.value;\n  }\n\n  getRole(name) {\n    return this.rolesSource.value[name];\n  }\n\n  hasOnlyRoles(names) {\n    const isNamesEmpty = !names || Array.isArray(names) && names.length === 0;\n\n    if (isNamesEmpty) {\n      return Promise.resolve(true);\n    }\n\n    names = transformStringToArray(names);\n    return Promise.all([this.hasRoleKey(names), this.hasRolePermission(this.rolesSource.value, names)]).then(([hasRoles, hasPermissions]) => {\n      return hasRoles || hasPermissions;\n    });\n  }\n\n  hasRoleKey(roleName) {\n    const promises = roleName.map(key => {\n      const hasValidationFunction = !!this.rolesSource.value[key] && !!this.rolesSource.value[key].validationFunction && isFunction(this.rolesSource.value[key].validationFunction);\n\n      if (hasValidationFunction && !isPromise(this.rolesSource.value[key].validationFunction)) {\n        const validationFunction = this.rolesSource.value[key].validationFunction;\n        const immutableValue = Object.assign({}, this.rolesSource.value);\n        return of(null).pipe(map(() => validationFunction(key, immutableValue)), switchMap(promise => isBoolean(promise) ? of(promise) : promise), catchError(() => of(false)));\n      }\n\n      return of(false);\n    });\n    return from(promises).pipe(mergeAll(), first(data => data !== false, false), map(data => data !== false)).toPromise().then(data => data);\n  }\n\n  hasRolePermission(roles, roleNames) {\n    return from(roleNames).pipe(mergeMap(key => {\n      if (roles[key] && Array.isArray(roles[key].validationFunction)) {\n        return from(roles[key].validationFunction).pipe(mergeMap(permission => this.permissionsService.hasPermission(permission)), every(hasPermission => hasPermission === true));\n      }\n\n      return of(false);\n    }), first(hasPermission => hasPermission === true, false)).toPromise();\n  }\n\n}\n\nNgxRolesService.ɵfac = function NgxRolesService_Factory(t) {\n  return new (t || NgxRolesService)(i0.ɵɵinject(USE_ROLES_STORE), i0.ɵɵinject(NgxRolesStore), i0.ɵɵinject(NgxPermissionsService));\n};\n\nNgxRolesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxRolesService,\n  factory: NgxRolesService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxRolesService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [USE_ROLES_STORE]\n      }]\n    }, {\n      type: NgxRolesStore\n    }, {\n      type: NgxPermissionsService\n    }];\n  }, null);\n})();\n\nclass NgxPermissionsDirective {\n  constructor(permissionsService, configurationService, rolesService, viewContainer, changeDetector, templateRef) {\n    this.permissionsService = permissionsService;\n    this.configurationService = configurationService;\n    this.rolesService = rolesService;\n    this.viewContainer = viewContainer;\n    this.changeDetector = changeDetector;\n    this.templateRef = templateRef;\n    this.permissionsAuthorized = new EventEmitter();\n    this.permissionsUnauthorized = new EventEmitter(); // skip first run cause merge will fire twice\n\n    this.firstMergeUnusedRun = 1;\n  }\n\n  ngOnInit() {\n    this.viewContainer.clear();\n    this.initPermissionSubscription = this.validateExceptOnlyPermissions();\n  }\n\n  ngOnChanges(changes) {\n    const onlyChanges = changes.ngxPermissionsOnly;\n    const exceptChanges = changes.ngxPermissionsExcept;\n\n    if (onlyChanges || exceptChanges) {\n      // Due to bug when you pass empty array\n      if (onlyChanges && onlyChanges.firstChange) {\n        return;\n      }\n\n      if (exceptChanges && exceptChanges.firstChange) {\n        return;\n      }\n\n      merge(this.permissionsService.permissions$, this.rolesService.roles$).pipe(skip(this.firstMergeUnusedRun), take(1)).subscribe(() => {\n        if (notEmptyValue(this.ngxPermissionsExcept)) {\n          this.validateExceptAndOnlyPermissions();\n          return;\n        }\n\n        if (notEmptyValue(this.ngxPermissionsOnly)) {\n          this.validateOnlyPermissions();\n          return;\n        }\n\n        this.handleAuthorisedPermission(this.getAuthorisedTemplates());\n      });\n    }\n  }\n\n  ngOnDestroy() {\n    if (this.initPermissionSubscription) {\n      this.initPermissionSubscription.unsubscribe();\n    }\n  }\n\n  validateExceptOnlyPermissions() {\n    return merge(this.permissionsService.permissions$, this.rolesService.roles$).pipe(skip(this.firstMergeUnusedRun)).subscribe(() => {\n      if (notEmptyValue(this.ngxPermissionsExcept)) {\n        this.validateExceptAndOnlyPermissions();\n        return;\n      }\n\n      if (notEmptyValue(this.ngxPermissionsOnly)) {\n        this.validateOnlyPermissions();\n        return;\n      }\n\n      this.handleAuthorisedPermission(this.getAuthorisedTemplates());\n    });\n  }\n\n  validateExceptAndOnlyPermissions() {\n    Promise.all([this.permissionsService.hasPermission(this.ngxPermissionsExcept), this.rolesService.hasOnlyRoles(this.ngxPermissionsExcept)]).then(([hasPermission, hasRole]) => {\n      if (hasPermission || hasRole) {\n        this.handleUnauthorisedPermission(this.ngxPermissionsExceptElse || this.ngxPermissionsElse);\n        return;\n      }\n\n      if (!!this.ngxPermissionsOnly) {\n        throw false;\n      }\n\n      this.handleAuthorisedPermission(this.ngxPermissionsExceptThen || this.ngxPermissionsThen || this.templateRef);\n    }).catch(() => {\n      if (!!this.ngxPermissionsOnly) {\n        this.validateOnlyPermissions();\n      } else {\n        this.handleAuthorisedPermission(this.ngxPermissionsExceptThen || this.ngxPermissionsThen || this.templateRef);\n      }\n    });\n  }\n\n  validateOnlyPermissions() {\n    Promise.all([this.permissionsService.hasPermission(this.ngxPermissionsOnly), this.rolesService.hasOnlyRoles(this.ngxPermissionsOnly)]).then(([hasPermissions, hasRoles]) => {\n      if (hasPermissions || hasRoles) {\n        this.handleAuthorisedPermission(this.ngxPermissionsOnlyThen || this.ngxPermissionsThen || this.templateRef);\n      } else {\n        this.handleUnauthorisedPermission(this.ngxPermissionsOnlyElse || this.ngxPermissionsElse);\n      }\n    }).catch(() => {\n      this.handleUnauthorisedPermission(this.ngxPermissionsOnlyElse || this.ngxPermissionsElse);\n    });\n  }\n\n  handleUnauthorisedPermission(template) {\n    if (isBoolean(this.currentAuthorizedState) && !this.currentAuthorizedState) {\n      return;\n    }\n\n    this.currentAuthorizedState = false;\n    this.permissionsUnauthorized.emit();\n\n    if (this.getUnAuthorizedStrategyInput()) {\n      this.applyStrategyAccordingToStrategyType(this.getUnAuthorizedStrategyInput());\n      return;\n    }\n\n    if (this.configurationService.onUnAuthorisedDefaultStrategy && !this.elseBlockDefined()) {\n      this.applyStrategy(this.configurationService.onUnAuthorisedDefaultStrategy);\n    } else {\n      this.showTemplateBlockInView(template);\n    }\n  }\n\n  handleAuthorisedPermission(template) {\n    if (isBoolean(this.currentAuthorizedState) && this.currentAuthorizedState) {\n      return;\n    }\n\n    this.currentAuthorizedState = true;\n    this.permissionsAuthorized.emit();\n\n    if (this.getAuthorizedStrategyInput()) {\n      this.applyStrategyAccordingToStrategyType(this.getAuthorizedStrategyInput());\n      return;\n    }\n\n    if (this.configurationService.onAuthorisedDefaultStrategy && !this.thenBlockDefined()) {\n      this.applyStrategy(this.configurationService.onAuthorisedDefaultStrategy);\n    } else {\n      this.showTemplateBlockInView(template);\n    }\n  }\n\n  applyStrategyAccordingToStrategyType(strategy) {\n    if (isString(strategy)) {\n      this.applyStrategy(strategy);\n      return;\n    }\n\n    if (isFunction(strategy)) {\n      this.showTemplateBlockInView(this.templateRef);\n      strategy(this.templateRef);\n      return;\n    }\n  }\n\n  showTemplateBlockInView(template) {\n    this.viewContainer.clear();\n\n    if (!template) {\n      return;\n    }\n\n    this.viewContainer.createEmbeddedView(template);\n    this.changeDetector.markForCheck();\n  }\n\n  getAuthorisedTemplates() {\n    return this.ngxPermissionsOnlyThen || this.ngxPermissionsExceptThen || this.ngxPermissionsThen || this.templateRef;\n  }\n\n  elseBlockDefined() {\n    return !!this.ngxPermissionsExceptElse || !!this.ngxPermissionsElse;\n  }\n\n  thenBlockDefined() {\n    return !!this.ngxPermissionsExceptThen || !!this.ngxPermissionsThen;\n  }\n\n  getAuthorizedStrategyInput() {\n    return this.ngxPermissionsOnlyAuthorisedStrategy || this.ngxPermissionsExceptAuthorisedStrategy || this.ngxPermissionsAuthorisedStrategy;\n  }\n\n  getUnAuthorizedStrategyInput() {\n    return this.ngxPermissionsOnlyUnauthorisedStrategy || this.ngxPermissionsExceptUnauthorisedStrategy || this.ngxPermissionsUnauthorisedStrategy;\n  }\n\n  applyStrategy(name) {\n    if (name === NgxPermissionsPredefinedStrategies.SHOW) {\n      this.showTemplateBlockInView(this.templateRef);\n      return;\n    }\n\n    if (name === NgxPermissionsPredefinedStrategies.REMOVE) {\n      this.viewContainer.clear();\n      return;\n    }\n\n    const strategy = this.configurationService.getStrategy(name);\n    this.showTemplateBlockInView(this.templateRef);\n    strategy(this.templateRef);\n  }\n\n}\n\nNgxPermissionsDirective.ɵfac = function NgxPermissionsDirective_Factory(t) {\n  return new (t || NgxPermissionsDirective)(i0.ɵɵdirectiveInject(NgxPermissionsService), i0.ɵɵdirectiveInject(NgxPermissionsConfigurationService), i0.ɵɵdirectiveInject(NgxRolesService), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.TemplateRef));\n};\n\nNgxPermissionsDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: NgxPermissionsDirective,\n  selectors: [[\"\", \"ngxPermissionsOnly\", \"\"], [\"\", \"ngxPermissionsExcept\", \"\"]],\n  inputs: {\n    ngxPermissionsOnly: \"ngxPermissionsOnly\",\n    ngxPermissionsOnlyThen: \"ngxPermissionsOnlyThen\",\n    ngxPermissionsOnlyElse: \"ngxPermissionsOnlyElse\",\n    ngxPermissionsExcept: \"ngxPermissionsExcept\",\n    ngxPermissionsExceptElse: \"ngxPermissionsExceptElse\",\n    ngxPermissionsExceptThen: \"ngxPermissionsExceptThen\",\n    ngxPermissionsThen: \"ngxPermissionsThen\",\n    ngxPermissionsElse: \"ngxPermissionsElse\",\n    ngxPermissionsOnlyAuthorisedStrategy: \"ngxPermissionsOnlyAuthorisedStrategy\",\n    ngxPermissionsOnlyUnauthorisedStrategy: \"ngxPermissionsOnlyUnauthorisedStrategy\",\n    ngxPermissionsExceptUnauthorisedStrategy: \"ngxPermissionsExceptUnauthorisedStrategy\",\n    ngxPermissionsExceptAuthorisedStrategy: \"ngxPermissionsExceptAuthorisedStrategy\",\n    ngxPermissionsUnauthorisedStrategy: \"ngxPermissionsUnauthorisedStrategy\",\n    ngxPermissionsAuthorisedStrategy: \"ngxPermissionsAuthorisedStrategy\"\n  },\n  outputs: {\n    permissionsAuthorized: \"permissionsAuthorized\",\n    permissionsUnauthorized: \"permissionsUnauthorized\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxPermissionsOnly],[ngxPermissionsExcept]'\n    }]\n  }], function () {\n    return [{\n      type: NgxPermissionsService\n    }, {\n      type: NgxPermissionsConfigurationService\n    }, {\n      type: NgxRolesService\n    }, {\n      type: i0.ViewContainerRef\n    }, {\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i0.TemplateRef\n    }];\n  }, {\n    ngxPermissionsOnly: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyThen: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyElse: [{\n      type: Input\n    }],\n    ngxPermissionsExcept: [{\n      type: Input\n    }],\n    ngxPermissionsExceptElse: [{\n      type: Input\n    }],\n    ngxPermissionsExceptThen: [{\n      type: Input\n    }],\n    ngxPermissionsThen: [{\n      type: Input\n    }],\n    ngxPermissionsElse: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyAuthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsExceptUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsExceptAuthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsAuthorisedStrategy: [{\n      type: Input\n    }],\n    permissionsAuthorized: [{\n      type: Output\n    }],\n    permissionsUnauthorized: [{\n      type: Output\n    }]\n  });\n})();\n\nconst DEFAULT_REDIRECT_KEY = 'default';\n\nclass NgxPermissionsGuard {\n  constructor(permissionsService, rolesService, router) {\n    this.permissionsService = permissionsService;\n    this.rolesService = rolesService;\n    this.router = router;\n  }\n\n  canActivate(route, state) {\n    return this.hasPermissions(route, state);\n  }\n\n  canActivateChild(childRoute, state) {\n    return this.hasPermissions(childRoute, state);\n  }\n\n  canLoad(route) {\n    return this.hasPermissions(route);\n  }\n\n  hasPermissions(route, state) {\n    const routeDataPermissions = !!route && route.data ? route.data.permissions : {};\n    const permissions = this.transformPermission(routeDataPermissions, route, state);\n\n    if (this.isParameterAvailable(permissions.except)) {\n      return this.passingExceptPermissionsValidation(permissions, route, state);\n    }\n\n    if (this.isParameterAvailable(permissions.only)) {\n      return this.passingOnlyPermissionsValidation(permissions, route, state);\n    }\n\n    return true;\n  }\n\n  transformPermission(permissions, route, state) {\n    const only = isFunction(permissions.only) ? permissions.only(route, state) : transformStringToArray(permissions.only);\n    const except = isFunction(permissions.except) ? permissions.except(route, state) : transformStringToArray(permissions.except);\n    const redirectTo = permissions.redirectTo;\n    return {\n      only,\n      except,\n      redirectTo\n    };\n  }\n\n  isParameterAvailable(permission) {\n    return !!permission && permission.length > 0;\n  }\n\n  passingExceptPermissionsValidation(permissions, route, state) {\n    if (!!permissions.redirectTo && (isFunction(permissions.redirectTo) || isPlainObject(permissions.redirectTo) && !this.isRedirectionWithParameters(permissions.redirectTo))) {\n      let failedPermission = '';\n      return from(permissions.except).pipe(mergeMap(permissionsExcept => {\n        return forkJoin([this.permissionsService.hasPermission(permissionsExcept), this.rolesService.hasOnlyRoles(permissionsExcept)]).pipe(tap(hasPermissions => {\n          const dontHavePermissions = hasPermissions.every(hasPermission => hasPermission === false);\n\n          if (!dontHavePermissions) {\n            failedPermission = permissionsExcept;\n          }\n        }));\n      }), first(hasPermissions => hasPermissions.some(hasPermission => hasPermission === true), false), mergeMap(isAllFalse => {\n        if (!!failedPermission) {\n          this.handleRedirectOfFailedPermission(permissions, failedPermission, route, state);\n          return of(false);\n        }\n\n        if (!isAllFalse && permissions.only) {\n          return this.onlyRedirectCheck(permissions, route, state);\n        }\n\n        return of(!isAllFalse);\n      })).toPromise();\n    }\n\n    return Promise.all([this.permissionsService.hasPermission(permissions.except), this.rolesService.hasOnlyRoles(permissions.except)]).then(([hasPermission, hasRoles]) => {\n      if (hasPermission || hasRoles) {\n        if (permissions.redirectTo) {\n          this.redirectToAnotherRoute(permissions.redirectTo, route, state);\n        }\n\n        return false;\n      }\n\n      if (permissions.only) {\n        return this.checkOnlyPermissions(permissions, route, state);\n      }\n\n      return true;\n    });\n  }\n\n  redirectToAnotherRoute(permissionRedirectTo, route, state, failedPermissionName) {\n    const redirectTo = isFunction(permissionRedirectTo) ? permissionRedirectTo(failedPermissionName, route, state) : permissionRedirectTo;\n\n    if (this.isRedirectionWithParameters(redirectTo)) {\n      redirectTo.navigationCommands = this.transformNavigationCommands(redirectTo.navigationCommands, route, state);\n      redirectTo.navigationExtras = this.transformNavigationExtras(redirectTo.navigationExtras, route, state);\n      this.router.navigate(redirectTo.navigationCommands, redirectTo.navigationExtras);\n      return;\n    }\n\n    if (Array.isArray(redirectTo)) {\n      this.router.navigate(redirectTo);\n    } else {\n      this.router.navigate([redirectTo]);\n    }\n  }\n\n  isRedirectionWithParameters(object) {\n    return isPlainObject(object) && (!!object.navigationCommands || !!object.navigationExtras);\n  }\n\n  transformNavigationCommands(navigationCommands, route, state) {\n    return isFunction(navigationCommands) ? navigationCommands(route, state) : navigationCommands;\n  }\n\n  transformNavigationExtras(navigationExtras, route, state) {\n    return isFunction(navigationExtras) ? navigationExtras(route, state) : navigationExtras;\n  }\n\n  onlyRedirectCheck(permissions, route, state) {\n    let failedPermission = '';\n    return from(permissions.only).pipe(mergeMap(permissionsOnly => {\n      return forkJoin([this.permissionsService.hasPermission(permissionsOnly), this.rolesService.hasOnlyRoles(permissionsOnly)]).pipe(tap(hasPermissions => {\n        const failed = hasPermissions.every(hasPermission => hasPermission === false);\n\n        if (failed) {\n          failedPermission = permissionsOnly;\n        }\n      }));\n    }), first(hasPermissions => {\n      if (isFunction(permissions.redirectTo)) {\n        return hasPermissions.some(hasPermission => hasPermission === true);\n      }\n\n      return hasPermissions.every(hasPermission => hasPermission === false);\n    }, false), mergeMap(pass => {\n      if (isFunction(permissions.redirectTo)) {\n        if (pass) {\n          return of(true);\n        } else {\n          this.handleRedirectOfFailedPermission(permissions, failedPermission, route, state);\n          return of(false);\n        }\n      } else {\n        if (!!failedPermission) {\n          this.handleRedirectOfFailedPermission(permissions, failedPermission, route, state);\n        }\n\n        return of(!pass);\n      }\n    })).toPromise();\n  }\n\n  handleRedirectOfFailedPermission(permissions, failedPermission, route, state) {\n    if (this.isFailedPermissionPropertyOfRedirectTo(permissions, failedPermission)) {\n      this.redirectToAnotherRoute(permissions.redirectTo[failedPermission], route, state, failedPermission);\n    } else {\n      if (isFunction(permissions.redirectTo)) {\n        this.redirectToAnotherRoute(permissions.redirectTo, route, state, failedPermission);\n      } else {\n        this.redirectToAnotherRoute(permissions.redirectTo[DEFAULT_REDIRECT_KEY], route, state, failedPermission);\n      }\n    }\n  }\n\n  isFailedPermissionPropertyOfRedirectTo(permissions, failedPermission) {\n    return !!permissions.redirectTo && permissions.redirectTo[failedPermission];\n  }\n\n  checkOnlyPermissions(purePermissions, route, state) {\n    const permissions = Object.assign({}, purePermissions);\n    return Promise.all([this.permissionsService.hasPermission(permissions.only), this.rolesService.hasOnlyRoles(permissions.only)]).then(([hasPermission, hasRole]) => {\n      if (hasPermission || hasRole) {\n        return true;\n      }\n\n      if (permissions.redirectTo) {\n        this.redirectToAnotherRoute(permissions.redirectTo, route, state);\n      }\n\n      return false;\n    });\n  }\n\n  passingOnlyPermissionsValidation(permissions, route, state) {\n    if (isFunction(permissions.redirectTo) || isPlainObject(permissions.redirectTo) && !this.isRedirectionWithParameters(permissions.redirectTo)) {\n      return this.onlyRedirectCheck(permissions, route, state);\n    }\n\n    return this.checkOnlyPermissions(permissions, route, state);\n  }\n\n}\n\nNgxPermissionsGuard.ɵfac = function NgxPermissionsGuard_Factory(t) {\n  return new (t || NgxPermissionsGuard)(i0.ɵɵinject(NgxPermissionsService), i0.ɵɵinject(NgxRolesService), i0.ɵɵinject(i3.Router));\n};\n\nNgxPermissionsGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxPermissionsGuard,\n  factory: NgxPermissionsGuard.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsGuard, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: NgxPermissionsService\n    }, {\n      type: NgxRolesService\n    }, {\n      type: i3.Router\n    }];\n  }, null);\n})();\n\nclass NgxPermissionsAllowStubDirective {\n  constructor(viewContainer, templateRef) {\n    this.viewContainer = viewContainer;\n    this.templateRef = templateRef;\n    this.permissionsAuthorized = new EventEmitter();\n    this.permissionsUnauthorized = new EventEmitter();\n  }\n\n  ngOnInit() {\n    this.viewContainer.clear();\n    this.viewContainer.createEmbeddedView(this.getAuthorizedTemplate());\n    this.permissionsUnauthorized.emit();\n  }\n\n  getAuthorizedTemplate() {\n    return this.ngxPermissionsOnlyThen || this.ngxPermissionsExceptThen || this.ngxPermissionsThen || this.templateRef;\n  }\n\n}\n\nNgxPermissionsAllowStubDirective.ɵfac = function NgxPermissionsAllowStubDirective_Factory(t) {\n  return new (t || NgxPermissionsAllowStubDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.TemplateRef));\n};\n\nNgxPermissionsAllowStubDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: NgxPermissionsAllowStubDirective,\n  selectors: [[\"\", \"ngxPermissionsOnly\", \"\"], [\"\", \"ngxPermissionsExcept\", \"\"]],\n  inputs: {\n    ngxPermissionsOnly: \"ngxPermissionsOnly\",\n    ngxPermissionsOnlyThen: \"ngxPermissionsOnlyThen\",\n    ngxPermissionsOnlyElse: \"ngxPermissionsOnlyElse\",\n    ngxPermissionsExcept: \"ngxPermissionsExcept\",\n    ngxPermissionsExceptElse: \"ngxPermissionsExceptElse\",\n    ngxPermissionsExceptThen: \"ngxPermissionsExceptThen\",\n    ngxPermissionsThen: \"ngxPermissionsThen\",\n    ngxPermissionsElse: \"ngxPermissionsElse\",\n    ngxPermissionsOnlyAuthorisedStrategy: \"ngxPermissionsOnlyAuthorisedStrategy\",\n    ngxPermissionsOnlyUnauthorisedStrategy: \"ngxPermissionsOnlyUnauthorisedStrategy\",\n    ngxPermissionsExceptUnauthorisedStrategy: \"ngxPermissionsExceptUnauthorisedStrategy\",\n    ngxPermissionsExceptAuthorisedStrategy: \"ngxPermissionsExceptAuthorisedStrategy\",\n    ngxPermissionsUnauthorisedStrategy: \"ngxPermissionsUnauthorisedStrategy\",\n    ngxPermissionsAuthorisedStrategy: \"ngxPermissionsAuthorisedStrategy\"\n  },\n  outputs: {\n    permissionsAuthorized: \"permissionsAuthorized\",\n    permissionsUnauthorized: \"permissionsUnauthorized\"\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsAllowStubDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxPermissionsOnly],[ngxPermissionsExcept]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ViewContainerRef\n    }, {\n      type: i0.TemplateRef\n    }];\n  }, {\n    ngxPermissionsOnly: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyThen: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyElse: [{\n      type: Input\n    }],\n    ngxPermissionsExcept: [{\n      type: Input\n    }],\n    ngxPermissionsExceptElse: [{\n      type: Input\n    }],\n    ngxPermissionsExceptThen: [{\n      type: Input\n    }],\n    ngxPermissionsThen: [{\n      type: Input\n    }],\n    ngxPermissionsElse: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyAuthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsExceptUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsExceptAuthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsAuthorisedStrategy: [{\n      type: Input\n    }],\n    permissionsAuthorized: [{\n      type: Output\n    }],\n    permissionsUnauthorized: [{\n      type: Output\n    }]\n  });\n})();\n\nclass NgxPermissionsRestrictStubDirective {\n  constructor(viewContainer) {\n    this.viewContainer = viewContainer;\n    this.permissionsAuthorized = new EventEmitter();\n    this.permissionsUnauthorized = new EventEmitter();\n  }\n\n  ngOnInit() {\n    this.viewContainer.clear();\n\n    if (this.getUnAuthorizedTemplate()) {\n      this.viewContainer.createEmbeddedView(this.getUnAuthorizedTemplate());\n    }\n\n    this.permissionsUnauthorized.emit();\n  }\n\n  getUnAuthorizedTemplate() {\n    return this.ngxPermissionsOnlyElse || this.ngxPermissionsExceptElse || this.ngxPermissionsElse;\n  }\n\n}\n\nNgxPermissionsRestrictStubDirective.ɵfac = function NgxPermissionsRestrictStubDirective_Factory(t) {\n  return new (t || NgxPermissionsRestrictStubDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n};\n\nNgxPermissionsRestrictStubDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: NgxPermissionsRestrictStubDirective,\n  selectors: [[\"\", \"ngxPermissionsOnly\", \"\"], [\"\", \"ngxPermissionsExcept\", \"\"]],\n  inputs: {\n    ngxPermissionsOnly: \"ngxPermissionsOnly\",\n    ngxPermissionsOnlyThen: \"ngxPermissionsOnlyThen\",\n    ngxPermissionsOnlyElse: \"ngxPermissionsOnlyElse\",\n    ngxPermissionsExcept: \"ngxPermissionsExcept\",\n    ngxPermissionsExceptElse: \"ngxPermissionsExceptElse\",\n    ngxPermissionsExceptThen: \"ngxPermissionsExceptThen\",\n    ngxPermissionsThen: \"ngxPermissionsThen\",\n    ngxPermissionsElse: \"ngxPermissionsElse\",\n    ngxPermissionsOnlyAuthorisedStrategy: \"ngxPermissionsOnlyAuthorisedStrategy\",\n    ngxPermissionsOnlyUnauthorisedStrategy: \"ngxPermissionsOnlyUnauthorisedStrategy\",\n    ngxPermissionsExceptUnauthorisedStrategy: \"ngxPermissionsExceptUnauthorisedStrategy\",\n    ngxPermissionsExceptAuthorisedStrategy: \"ngxPermissionsExceptAuthorisedStrategy\",\n    ngxPermissionsUnauthorisedStrategy: \"ngxPermissionsUnauthorisedStrategy\",\n    ngxPermissionsAuthorisedStrategy: \"ngxPermissionsAuthorisedStrategy\"\n  },\n  outputs: {\n    permissionsAuthorized: \"permissionsAuthorized\",\n    permissionsUnauthorized: \"permissionsUnauthorized\"\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsRestrictStubDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxPermissionsOnly],[ngxPermissionsExcept]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ViewContainerRef\n    }];\n  }, {\n    ngxPermissionsOnly: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyThen: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyElse: [{\n      type: Input\n    }],\n    ngxPermissionsExcept: [{\n      type: Input\n    }],\n    ngxPermissionsExceptElse: [{\n      type: Input\n    }],\n    ngxPermissionsExceptThen: [{\n      type: Input\n    }],\n    ngxPermissionsThen: [{\n      type: Input\n    }],\n    ngxPermissionsElse: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyAuthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsExceptUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsExceptAuthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsAuthorisedStrategy: [{\n      type: Input\n    }],\n    permissionsAuthorized: [{\n      type: Output\n    }],\n    permissionsUnauthorized: [{\n      type: Output\n    }]\n  });\n})();\n\nclass NgxPermissionsModule {\n  static forRoot(config = {}) {\n    return {\n      ngModule: NgxPermissionsModule,\n      providers: [NgxPermissionsStore, NgxRolesStore, NgxPermissionsConfigurationStore, NgxPermissionsService, NgxPermissionsGuard, NgxRolesService, NgxPermissionsConfigurationService, {\n        provide: USE_PERMISSIONS_STORE,\n        useValue: config.permissionsIsolate\n      }, {\n        provide: USE_ROLES_STORE,\n        useValue: config.rolesIsolate\n      }, {\n        provide: USE_CONFIGURATION_STORE,\n        useValue: config.configurationIsolate\n      }]\n    };\n  }\n\n  static forChild(config = {}) {\n    return {\n      ngModule: NgxPermissionsModule,\n      providers: [{\n        provide: USE_PERMISSIONS_STORE,\n        useValue: config.permissionsIsolate\n      }, {\n        provide: USE_ROLES_STORE,\n        useValue: config.rolesIsolate\n      }, {\n        provide: USE_CONFIGURATION_STORE,\n        useValue: config.configurationIsolate\n      }, NgxPermissionsConfigurationService, NgxPermissionsService, NgxRolesService, NgxPermissionsGuard]\n    };\n  }\n\n}\n\nNgxPermissionsModule.ɵfac = function NgxPermissionsModule_Factory(t) {\n  return new (t || NgxPermissionsModule)();\n};\n\nNgxPermissionsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxPermissionsModule\n});\nNgxPermissionsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsModule, [{\n    type: NgModule,\n    args: [{\n      imports: [],\n      declarations: [NgxPermissionsDirective],\n      exports: [NgxPermissionsDirective]\n    }]\n  }], null, null);\n})();\n\nclass NgxPermissionsAllowStubModule {}\n\nNgxPermissionsAllowStubModule.ɵfac = function NgxPermissionsAllowStubModule_Factory(t) {\n  return new (t || NgxPermissionsAllowStubModule)();\n};\n\nNgxPermissionsAllowStubModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxPermissionsAllowStubModule\n});\nNgxPermissionsAllowStubModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsAllowStubModule, [{\n    type: NgModule,\n    args: [{\n      imports: [],\n      declarations: [NgxPermissionsAllowStubDirective],\n      exports: [NgxPermissionsAllowStubDirective]\n    }]\n  }], null, null);\n})();\n\nclass NgxPermissionsRestrictStubModule {}\n\nNgxPermissionsRestrictStubModule.ɵfac = function NgxPermissionsRestrictStubModule_Factory(t) {\n  return new (t || NgxPermissionsRestrictStubModule)();\n};\n\nNgxPermissionsRestrictStubModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxPermissionsRestrictStubModule\n});\nNgxPermissionsRestrictStubModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsRestrictStubModule, [{\n    type: NgModule,\n    args: [{\n      imports: [],\n      declarations: [NgxPermissionsRestrictStubDirective],\n      exports: [NgxPermissionsRestrictStubDirective]\n    }]\n  }], null, null);\n})();\n/*\n * Public API Surface of ngx-permissions\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { DEFAULT_REDIRECT_KEY, NgxPermissionsAllowStubDirective, NgxPermissionsAllowStubModule, NgxPermissionsConfigurationService, NgxPermissionsConfigurationStore, NgxPermissionsDirective, NgxPermissionsGuard, NgxPermissionsModule, NgxPermissionsPredefinedStrategies, NgxPermissionsRestrictStubDirective, NgxPermissionsRestrictStubModule, NgxPermissionsService, NgxPermissionsStore, NgxRolesService, NgxRolesStore, USE_CONFIGURATION_STORE, USE_PERMISSIONS_STORE, USE_ROLES_STORE };","map":{"version":3,"sources":["/home/vietnguyen/crm-gym-web-v2/node_modules/ngx-permissions/fesm2015/ngx-permissions.mjs"],"names":["i0","Injectable","InjectionToken","Inject","EventEmitter","Directive","Input","Output","NgModule","BehaviorSubject","of","from","merge","forkJoin","map","switchMap","catchError","mergeAll","first","mergeMap","every","skip","take","tap","i3","NgxPermissionsPredefinedStrategies","REMOVE","SHOW","isFunction","value","isPlainObject","Object","prototype","toString","call","getPrototypeOf","isString","isBoolean","isPromise","promise","notEmptyValue","Array","isArray","length","transformStringToArray","NgxPermissionsStore","constructor","permissionsSource","permissions$","asObservable","ɵfac","ɵprov","type","USE_PERMISSIONS_STORE","NgxPermissionsService","isolate","permissionsStore","flushPermissions","next","hasPermission","permission","Promise","resolve","hasArrayPermission","loadPermissions","permissions","validationFunction","newPermissions","reduce","source","name","reducePermission","addPermission","removePermission","permissionName","assign","getPermission","getPermissions","promises","key","hasPermissionValidationFunction","immutableValue","pipe","data","toPromise","then","undefined","decorators","args","NgxPermissionsConfigurationStore","strategiesSource","strategies$","USE_CONFIGURATION_STORE","NgxPermissionsConfigurationService","configurationStore","onAuthorisedDefaultStrategy","onUnAuthorisedDefaultStrategy","setDefaultOnAuthorizedStrategy","getDefinedStrategy","setDefaultOnUnauthorizedStrategy","addPermissionStrategy","func","getStrategy","getAllStrategies","isPredefinedStrategy","Error","strategy","NgxRolesStore","rolesSource","roles$","USE_ROLES_STORE","NgxRolesService","rolesStore","permissionsService","addRole","roles","addRoleWithPermissions","addRoles","rolesObj","keys","forEach","index","addRolesWithPermissions","flushRoles","flushRolesAndPermissions","removeRole","roleName","getRoles","getRole","hasOnlyRoles","names","isNamesEmpty","all","hasRoleKey","hasRolePermission","hasRoles","hasPermissions","hasValidationFunction","roleNames","NgxPermissionsDirective","configurationService","rolesService","viewContainer","changeDetector","templateRef","permissionsAuthorized","permissionsUnauthorized","firstMergeUnusedRun","ngOnInit","clear","initPermissionSubscription","validateExceptOnlyPermissions","ngOnChanges","changes","onlyChanges","ngxPermissionsOnly","exceptChanges","ngxPermissionsExcept","firstChange","subscribe","validateExceptAndOnlyPermissions","validateOnlyPermissions","handleAuthorisedPermission","getAuthorisedTemplates","ngOnDestroy","unsubscribe","hasRole","handleUnauthorisedPermission","ngxPermissionsExceptElse","ngxPermissionsElse","ngxPermissionsExceptThen","ngxPermissionsThen","catch","ngxPermissionsOnlyThen","ngxPermissionsOnlyElse","template","currentAuthorizedState","emit","getUnAuthorizedStrategyInput","applyStrategyAccordingToStrategyType","elseBlockDefined","applyStrategy","showTemplateBlockInView","getAuthorizedStrategyInput","thenBlockDefined","createEmbeddedView","markForCheck","ngxPermissionsOnlyAuthorisedStrategy","ngxPermissionsExceptAuthorisedStrategy","ngxPermissionsAuthorisedStrategy","ngxPermissionsOnlyUnauthorisedStrategy","ngxPermissionsExceptUnauthorisedStrategy","ngxPermissionsUnauthorisedStrategy","ViewContainerRef","ChangeDetectorRef","TemplateRef","ɵdir","selector","DEFAULT_REDIRECT_KEY","NgxPermissionsGuard","router","canActivate","route","state","canActivateChild","childRoute","canLoad","routeDataPermissions","transformPermission","isParameterAvailable","except","passingExceptPermissionsValidation","only","passingOnlyPermissionsValidation","redirectTo","isRedirectionWithParameters","failedPermission","permissionsExcept","dontHavePermissions","some","isAllFalse","handleRedirectOfFailedPermission","onlyRedirectCheck","redirectToAnotherRoute","checkOnlyPermissions","permissionRedirectTo","failedPermissionName","navigationCommands","transformNavigationCommands","navigationExtras","transformNavigationExtras","navigate","object","permissionsOnly","failed","pass","isFailedPermissionPropertyOfRedirectTo","purePermissions","Router","NgxPermissionsAllowStubDirective","getAuthorizedTemplate","NgxPermissionsRestrictStubDirective","getUnAuthorizedTemplate","NgxPermissionsModule","forRoot","config","ngModule","providers","provide","useValue","permissionsIsolate","rolesIsolate","configurationIsolate","forChild","ɵmod","ɵinj","imports","declarations","exports","NgxPermissionsAllowStubModule","NgxPermissionsRestrictStubModule"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, Inject, EventEmitter, Directive, Input, Output, NgModule } from '@angular/core';\nimport { BehaviorSubject, of, from, merge, forkJoin } from 'rxjs';\nimport { map, switchMap, catchError, mergeAll, first, mergeMap, every, skip, take, tap } from 'rxjs/operators';\nimport * as i3 from '@angular/router';\n\nconst NgxPermissionsPredefinedStrategies = {\n    REMOVE: 'remove',\n    SHOW: 'show'\n};\n\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\nfunction isPlainObject(value) {\n    if (Object.prototype.toString.call(value) !== '[object Object]') {\n        return false;\n    }\n    else {\n        const prototype = Object.getPrototypeOf(value);\n        return prototype === null || prototype === Object.prototype;\n    }\n}\nfunction isString(value) {\n    return !!value && typeof value === 'string';\n}\nfunction isBoolean(value) {\n    return typeof value === 'boolean';\n}\nfunction isPromise(promise) {\n    return Object.prototype.toString.call(promise) === '[object Promise]';\n}\nfunction notEmptyValue(value) {\n    if (Array.isArray(value)) {\n        return value.length > 0;\n    }\n    return !!value;\n}\nfunction transformStringToArray(value) {\n    if (isString(value)) {\n        return [value];\n    }\n    return value;\n}\n\nclass NgxPermissionsStore {\n    constructor() {\n        this.permissionsSource = new BehaviorSubject({});\n        this.permissions$ = this.permissionsSource.asObservable();\n    }\n}\nNgxPermissionsStore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsStore, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nNgxPermissionsStore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsStore });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsStore, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return []; } });\n\nconst USE_PERMISSIONS_STORE = new InjectionToken('USE_PERMISSIONS_STORE');\nclass NgxPermissionsService {\n    constructor(isolate = false, permissionsStore) {\n        this.isolate = isolate;\n        this.permissionsStore = permissionsStore;\n        this.permissionsSource = isolate ? new BehaviorSubject({}) : permissionsStore.permissionsSource;\n        this.permissions$ = this.permissionsSource.asObservable();\n    }\n    /**\n     * Remove all permissions from permissions source\n     */\n    flushPermissions() {\n        this.permissionsSource.next({});\n    }\n    hasPermission(permission) {\n        if (!permission || (Array.isArray(permission) && permission.length === 0)) {\n            return Promise.resolve(true);\n        }\n        permission = transformStringToArray(permission);\n        return this.hasArrayPermission(permission);\n    }\n    loadPermissions(permissions, validationFunction) {\n        const newPermissions = permissions.reduce((source, name) => this.reducePermission(source, name, validationFunction), {});\n        this.permissionsSource.next(newPermissions);\n    }\n    addPermission(permission, validationFunction) {\n        if (Array.isArray(permission)) {\n            const permissions = permission.reduce((source, name) => this.reducePermission(source, name, validationFunction), this.permissionsSource.value);\n            this.permissionsSource.next(permissions);\n        }\n        else {\n            const permissions = this.reducePermission(this.permissionsSource.value, permission, validationFunction);\n            this.permissionsSource.next(permissions);\n        }\n    }\n    removePermission(permissionName) {\n        const permissions = Object.assign({}, this.permissionsSource.value);\n        delete permissions[permissionName];\n        this.permissionsSource.next(permissions);\n    }\n    getPermission(name) {\n        return this.permissionsSource.value[name];\n    }\n    getPermissions() {\n        return this.permissionsSource.value;\n    }\n    reducePermission(source, name, validationFunction) {\n        if (!!validationFunction && isFunction(validationFunction)) {\n            return Object.assign(Object.assign({}, source), { [name]: { name, validationFunction } });\n        }\n        return Object.assign(Object.assign({}, source), { [name]: { name } });\n    }\n    hasArrayPermission(permissions) {\n        const promises = permissions.map(key => {\n            if (this.hasPermissionValidationFunction(key)) {\n                const validationFunction = this.permissionsSource.value[key].validationFunction;\n                const immutableValue = Object.assign({}, this.permissionsSource.value);\n                return of(null).pipe(map(() => validationFunction(key, immutableValue)), switchMap((promise) => isBoolean(promise) ?\n                    of(promise) : promise), catchError(() => of(false)));\n            }\n            // check for name of the permission if there is no validation function\n            return of(!!this.permissionsSource.value[key]);\n        });\n        return from(promises).pipe(mergeAll(), first((data) => data !== false, false), map((data) => data !== false)).toPromise().then((data) => data);\n    }\n    hasPermissionValidationFunction(key) {\n        return !!this.permissionsSource.value[key] &&\n            !!this.permissionsSource.value[key].validationFunction &&\n            isFunction(this.permissionsSource.value[key].validationFunction);\n    }\n}\nNgxPermissionsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsService, deps: [{ token: USE_PERMISSIONS_STORE }, { token: NgxPermissionsStore }], target: i0.ɵɵFactoryTarget.Injectable });\nNgxPermissionsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () {\n        return [{ type: undefined, decorators: [{\n                        type: Inject,\n                        args: [USE_PERMISSIONS_STORE]\n                    }] }, { type: NgxPermissionsStore }];\n    } });\n\nclass NgxPermissionsConfigurationStore {\n    constructor() {\n        this.strategiesSource = new BehaviorSubject({});\n        this.strategies$ = this.strategiesSource.asObservable();\n    }\n}\nNgxPermissionsConfigurationStore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsConfigurationStore, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nNgxPermissionsConfigurationStore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsConfigurationStore });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsConfigurationStore, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return []; } });\n\nconst USE_CONFIGURATION_STORE = new InjectionToken('USE_CONFIGURATION_STORE');\nclass NgxPermissionsConfigurationService {\n    constructor(isolate = false, configurationStore) {\n        this.isolate = isolate;\n        this.configurationStore = configurationStore;\n        this.strategiesSource = this.isolate ? new BehaviorSubject({}) : this.configurationStore.strategiesSource;\n        this.strategies$ = this.strategiesSource.asObservable();\n        this.onAuthorisedDefaultStrategy = this.isolate ? undefined : this.configurationStore.onAuthorisedDefaultStrategy;\n        this.onUnAuthorisedDefaultStrategy = this.isolate ? undefined : this.configurationStore.onUnAuthorisedDefaultStrategy;\n    }\n    setDefaultOnAuthorizedStrategy(name) {\n        if (this.isolate) {\n            this.onAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n        }\n        else {\n            this.configurationStore.onAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n            this.onAuthorisedDefaultStrategy = this.configurationStore.onAuthorisedDefaultStrategy;\n        }\n    }\n    setDefaultOnUnauthorizedStrategy(name) {\n        if (this.isolate) {\n            this.onUnAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n        }\n        else {\n            this.configurationStore.onUnAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n            this.onUnAuthorisedDefaultStrategy = this.configurationStore.onUnAuthorisedDefaultStrategy;\n        }\n    }\n    addPermissionStrategy(key, func) {\n        this.strategiesSource.value[key] = func;\n    }\n    getStrategy(key) {\n        return this.strategiesSource.value[key];\n    }\n    getAllStrategies() {\n        return this.strategiesSource.value;\n    }\n    getDefinedStrategy(name) {\n        if (this.strategiesSource.value[name] || this.isPredefinedStrategy(name)) {\n            return name;\n        }\n        else {\n            throw new Error(`No ' ${name} ' strategy is found please define one`);\n        }\n    }\n    isPredefinedStrategy(strategy) {\n        return strategy === NgxPermissionsPredefinedStrategies.SHOW || strategy === NgxPermissionsPredefinedStrategies.REMOVE;\n    }\n}\nNgxPermissionsConfigurationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsConfigurationService, deps: [{ token: USE_CONFIGURATION_STORE }, { token: NgxPermissionsConfigurationStore }], target: i0.ɵɵFactoryTarget.Injectable });\nNgxPermissionsConfigurationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsConfigurationService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsConfigurationService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () {\n        return [{ type: undefined, decorators: [{\n                        type: Inject,\n                        args: [USE_CONFIGURATION_STORE]\n                    }] }, { type: NgxPermissionsConfigurationStore }];\n    } });\n\nclass NgxRolesStore {\n    constructor() {\n        this.rolesSource = new BehaviorSubject({});\n        this.roles$ = this.rolesSource.asObservable();\n    }\n}\n\nconst USE_ROLES_STORE = new InjectionToken('USE_ROLES_STORE');\nclass NgxRolesService {\n    constructor(isolate = false, rolesStore, permissionsService) {\n        this.isolate = isolate;\n        this.rolesStore = rolesStore;\n        this.permissionsService = permissionsService;\n        this.rolesSource = this.isolate ? new BehaviorSubject({}) : this.rolesStore.rolesSource;\n        this.roles$ = this.rolesSource.asObservable();\n    }\n    addRole(name, validationFunction) {\n        const roles = Object.assign(Object.assign({}, this.rolesSource.value), { [name]: { name, validationFunction } });\n        this.rolesSource.next(roles);\n    }\n    addRoleWithPermissions(name, permissions) {\n        this.permissionsService.addPermission(permissions);\n        this.addRole(name, permissions);\n    }\n    addRoles(rolesObj) {\n        Object.keys(rolesObj).forEach((key, index) => {\n            this.addRole(key, rolesObj[key]);\n        });\n    }\n    addRolesWithPermissions(rolesObj) {\n        Object.keys(rolesObj).forEach((key, index) => {\n            this.addRoleWithPermissions(key, rolesObj[key]);\n        });\n    }\n    flushRoles() {\n        this.rolesSource.next({});\n    }\n    flushRolesAndPermissions() {\n        this.flushRoles();\n        this.permissionsService.flushPermissions();\n    }\n    removeRole(roleName) {\n        const roles = Object.assign({}, this.rolesSource.value);\n        delete roles[roleName];\n        this.rolesSource.next(roles);\n    }\n    getRoles() {\n        return this.rolesSource.value;\n    }\n    getRole(name) {\n        return this.rolesSource.value[name];\n    }\n    hasOnlyRoles(names) {\n        const isNamesEmpty = !names || (Array.isArray(names) && names.length === 0);\n        if (isNamesEmpty) {\n            return Promise.resolve(true);\n        }\n        names = transformStringToArray(names);\n        return Promise.all([this.hasRoleKey(names), this.hasRolePermission(this.rolesSource.value, names)])\n            .then(([hasRoles, hasPermissions]) => {\n            return hasRoles || hasPermissions;\n        });\n    }\n    hasRoleKey(roleName) {\n        const promises = roleName.map((key) => {\n            const hasValidationFunction = !!this.rolesSource.value[key] &&\n                !!this.rolesSource.value[key].validationFunction &&\n                isFunction(this.rolesSource.value[key].validationFunction);\n            if (hasValidationFunction && !isPromise(this.rolesSource.value[key].validationFunction)) {\n                const validationFunction = this.rolesSource.value[key].validationFunction;\n                const immutableValue = Object.assign({}, this.rolesSource.value);\n                return of(null).pipe(map(() => validationFunction(key, immutableValue)), switchMap((promise) => isBoolean(promise) ?\n                    of(promise) : promise), catchError(() => of(false)));\n            }\n            return of(false);\n        });\n        return from(promises).pipe(mergeAll(), first((data) => data !== false, false), map((data) => data !== false)).toPromise().then((data) => data);\n    }\n    hasRolePermission(roles, roleNames) {\n        return from(roleNames).pipe(mergeMap((key) => {\n            if (roles[key] && Array.isArray(roles[key].validationFunction)) {\n                return from(roles[key].validationFunction).pipe(mergeMap((permission) => this.permissionsService.hasPermission(permission)), every(hasPermission => hasPermission === true));\n            }\n            return of(false);\n        }), first(hasPermission => hasPermission === true, false)).toPromise();\n    }\n}\nNgxRolesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxRolesService, deps: [{ token: USE_ROLES_STORE }, { token: NgxRolesStore }, { token: NgxPermissionsService }], target: i0.ɵɵFactoryTarget.Injectable });\nNgxRolesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxRolesService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxRolesService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () {\n        return [{ type: undefined, decorators: [{\n                        type: Inject,\n                        args: [USE_ROLES_STORE]\n                    }] }, { type: NgxRolesStore }, { type: NgxPermissionsService }];\n    } });\n\nclass NgxPermissionsDirective {\n    constructor(permissionsService, configurationService, rolesService, viewContainer, changeDetector, templateRef) {\n        this.permissionsService = permissionsService;\n        this.configurationService = configurationService;\n        this.rolesService = rolesService;\n        this.viewContainer = viewContainer;\n        this.changeDetector = changeDetector;\n        this.templateRef = templateRef;\n        this.permissionsAuthorized = new EventEmitter();\n        this.permissionsUnauthorized = new EventEmitter();\n        // skip first run cause merge will fire twice\n        this.firstMergeUnusedRun = 1;\n    }\n    ngOnInit() {\n        this.viewContainer.clear();\n        this.initPermissionSubscription = this.validateExceptOnlyPermissions();\n    }\n    ngOnChanges(changes) {\n        const onlyChanges = changes.ngxPermissionsOnly;\n        const exceptChanges = changes.ngxPermissionsExcept;\n        if (onlyChanges || exceptChanges) {\n            // Due to bug when you pass empty array\n            if (onlyChanges && onlyChanges.firstChange) {\n                return;\n            }\n            if (exceptChanges && exceptChanges.firstChange) {\n                return;\n            }\n            merge(this.permissionsService.permissions$, this.rolesService.roles$)\n                .pipe(skip(this.firstMergeUnusedRun), take(1))\n                .subscribe(() => {\n                if (notEmptyValue(this.ngxPermissionsExcept)) {\n                    this.validateExceptAndOnlyPermissions();\n                    return;\n                }\n                if (notEmptyValue(this.ngxPermissionsOnly)) {\n                    this.validateOnlyPermissions();\n                    return;\n                }\n                this.handleAuthorisedPermission(this.getAuthorisedTemplates());\n            });\n        }\n    }\n    ngOnDestroy() {\n        if (this.initPermissionSubscription) {\n            this.initPermissionSubscription.unsubscribe();\n        }\n    }\n    validateExceptOnlyPermissions() {\n        return merge(this.permissionsService.permissions$, this.rolesService.roles$)\n            .pipe(skip(this.firstMergeUnusedRun))\n            .subscribe(() => {\n            if (notEmptyValue(this.ngxPermissionsExcept)) {\n                this.validateExceptAndOnlyPermissions();\n                return;\n            }\n            if (notEmptyValue(this.ngxPermissionsOnly)) {\n                this.validateOnlyPermissions();\n                return;\n            }\n            this.handleAuthorisedPermission(this.getAuthorisedTemplates());\n        });\n    }\n    validateExceptAndOnlyPermissions() {\n        Promise\n            .all([\n            this.permissionsService.hasPermission(this.ngxPermissionsExcept),\n            this.rolesService.hasOnlyRoles(this.ngxPermissionsExcept)\n        ])\n            .then(([hasPermission, hasRole]) => {\n            if (hasPermission || hasRole) {\n                this.handleUnauthorisedPermission(this.ngxPermissionsExceptElse || this.ngxPermissionsElse);\n                return;\n            }\n            if (!!this.ngxPermissionsOnly) {\n                throw false;\n            }\n            this.handleAuthorisedPermission(this.ngxPermissionsExceptThen || this.ngxPermissionsThen || this.templateRef);\n        })\n            .catch(() => {\n            if (!!this.ngxPermissionsOnly) {\n                this.validateOnlyPermissions();\n            }\n            else {\n                this.handleAuthorisedPermission(this.ngxPermissionsExceptThen || this.ngxPermissionsThen || this.templateRef);\n            }\n        });\n    }\n    validateOnlyPermissions() {\n        Promise\n            .all([this.permissionsService.hasPermission(this.ngxPermissionsOnly), this.rolesService.hasOnlyRoles(this.ngxPermissionsOnly)])\n            .then(([hasPermissions, hasRoles]) => {\n            if (hasPermissions || hasRoles) {\n                this.handleAuthorisedPermission(this.ngxPermissionsOnlyThen || this.ngxPermissionsThen || this.templateRef);\n            }\n            else {\n                this.handleUnauthorisedPermission(this.ngxPermissionsOnlyElse || this.ngxPermissionsElse);\n            }\n        })\n            .catch(() => {\n            this.handleUnauthorisedPermission(this.ngxPermissionsOnlyElse || this.ngxPermissionsElse);\n        });\n    }\n    handleUnauthorisedPermission(template) {\n        if (isBoolean(this.currentAuthorizedState) && !this.currentAuthorizedState) {\n            return;\n        }\n        this.currentAuthorizedState = false;\n        this.permissionsUnauthorized.emit();\n        if (this.getUnAuthorizedStrategyInput()) {\n            this.applyStrategyAccordingToStrategyType(this.getUnAuthorizedStrategyInput());\n            return;\n        }\n        if (this.configurationService.onUnAuthorisedDefaultStrategy && !this.elseBlockDefined()) {\n            this.applyStrategy(this.configurationService.onUnAuthorisedDefaultStrategy);\n        }\n        else {\n            this.showTemplateBlockInView(template);\n        }\n    }\n    handleAuthorisedPermission(template) {\n        if (isBoolean(this.currentAuthorizedState) && this.currentAuthorizedState) {\n            return;\n        }\n        this.currentAuthorizedState = true;\n        this.permissionsAuthorized.emit();\n        if (this.getAuthorizedStrategyInput()) {\n            this.applyStrategyAccordingToStrategyType(this.getAuthorizedStrategyInput());\n            return;\n        }\n        if (this.configurationService.onAuthorisedDefaultStrategy && !this.thenBlockDefined()) {\n            this.applyStrategy(this.configurationService.onAuthorisedDefaultStrategy);\n        }\n        else {\n            this.showTemplateBlockInView(template);\n        }\n    }\n    applyStrategyAccordingToStrategyType(strategy) {\n        if (isString(strategy)) {\n            this.applyStrategy(strategy);\n            return;\n        }\n        if (isFunction(strategy)) {\n            this.showTemplateBlockInView(this.templateRef);\n            strategy(this.templateRef);\n            return;\n        }\n    }\n    showTemplateBlockInView(template) {\n        this.viewContainer.clear();\n        if (!template) {\n            return;\n        }\n        this.viewContainer.createEmbeddedView(template);\n        this.changeDetector.markForCheck();\n    }\n    getAuthorisedTemplates() {\n        return this.ngxPermissionsOnlyThen\n            || this.ngxPermissionsExceptThen\n            || this.ngxPermissionsThen\n            || this.templateRef;\n    }\n    elseBlockDefined() {\n        return !!this.ngxPermissionsExceptElse || !!this.ngxPermissionsElse;\n    }\n    thenBlockDefined() {\n        return !!this.ngxPermissionsExceptThen || !!this.ngxPermissionsThen;\n    }\n    getAuthorizedStrategyInput() {\n        return this.ngxPermissionsOnlyAuthorisedStrategy ||\n            this.ngxPermissionsExceptAuthorisedStrategy ||\n            this.ngxPermissionsAuthorisedStrategy;\n    }\n    getUnAuthorizedStrategyInput() {\n        return this.ngxPermissionsOnlyUnauthorisedStrategy ||\n            this.ngxPermissionsExceptUnauthorisedStrategy ||\n            this.ngxPermissionsUnauthorisedStrategy;\n    }\n    applyStrategy(name) {\n        if (name === NgxPermissionsPredefinedStrategies.SHOW) {\n            this.showTemplateBlockInView(this.templateRef);\n            return;\n        }\n        if (name === NgxPermissionsPredefinedStrategies.REMOVE) {\n            this.viewContainer.clear();\n            return;\n        }\n        const strategy = this.configurationService.getStrategy(name);\n        this.showTemplateBlockInView(this.templateRef);\n        strategy(this.templateRef);\n    }\n}\nNgxPermissionsDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsDirective, deps: [{ token: NgxPermissionsService }, { token: NgxPermissionsConfigurationService }, { token: NgxRolesService }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }, { token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });\nNgxPermissionsDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.0.2\", type: NgxPermissionsDirective, selector: \"[ngxPermissionsOnly],[ngxPermissionsExcept]\", inputs: { ngxPermissionsOnly: \"ngxPermissionsOnly\", ngxPermissionsOnlyThen: \"ngxPermissionsOnlyThen\", ngxPermissionsOnlyElse: \"ngxPermissionsOnlyElse\", ngxPermissionsExcept: \"ngxPermissionsExcept\", ngxPermissionsExceptElse: \"ngxPermissionsExceptElse\", ngxPermissionsExceptThen: \"ngxPermissionsExceptThen\", ngxPermissionsThen: \"ngxPermissionsThen\", ngxPermissionsElse: \"ngxPermissionsElse\", ngxPermissionsOnlyAuthorisedStrategy: \"ngxPermissionsOnlyAuthorisedStrategy\", ngxPermissionsOnlyUnauthorisedStrategy: \"ngxPermissionsOnlyUnauthorisedStrategy\", ngxPermissionsExceptUnauthorisedStrategy: \"ngxPermissionsExceptUnauthorisedStrategy\", ngxPermissionsExceptAuthorisedStrategy: \"ngxPermissionsExceptAuthorisedStrategy\", ngxPermissionsUnauthorisedStrategy: \"ngxPermissionsUnauthorisedStrategy\", ngxPermissionsAuthorisedStrategy: \"ngxPermissionsAuthorisedStrategy\" }, outputs: { permissionsAuthorized: \"permissionsAuthorized\", permissionsUnauthorized: \"permissionsUnauthorized\" }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxPermissionsOnly],[ngxPermissionsExcept]'\n                }]\n        }], ctorParameters: function () { return [{ type: NgxPermissionsService }, { type: NgxPermissionsConfigurationService }, { type: NgxRolesService }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }, { type: i0.TemplateRef }]; }, propDecorators: { ngxPermissionsOnly: [{\n                type: Input\n            }], ngxPermissionsOnlyThen: [{\n                type: Input\n            }], ngxPermissionsOnlyElse: [{\n                type: Input\n            }], ngxPermissionsExcept: [{\n                type: Input\n            }], ngxPermissionsExceptElse: [{\n                type: Input\n            }], ngxPermissionsExceptThen: [{\n                type: Input\n            }], ngxPermissionsThen: [{\n                type: Input\n            }], ngxPermissionsElse: [{\n                type: Input\n            }], ngxPermissionsOnlyAuthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsOnlyUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsExceptUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsExceptAuthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsAuthorisedStrategy: [{\n                type: Input\n            }], permissionsAuthorized: [{\n                type: Output\n            }], permissionsUnauthorized: [{\n                type: Output\n            }] } });\n\nconst DEFAULT_REDIRECT_KEY = 'default';\n\nclass NgxPermissionsGuard {\n    constructor(permissionsService, rolesService, router) {\n        this.permissionsService = permissionsService;\n        this.rolesService = rolesService;\n        this.router = router;\n    }\n    canActivate(route, state) {\n        return this.hasPermissions(route, state);\n    }\n    canActivateChild(childRoute, state) {\n        return this.hasPermissions(childRoute, state);\n    }\n    canLoad(route) {\n        return this.hasPermissions(route);\n    }\n    hasPermissions(route, state) {\n        const routeDataPermissions = !!route && route.data ? route.data.permissions : {};\n        const permissions = this.transformPermission(routeDataPermissions, route, state);\n        if (this.isParameterAvailable(permissions.except)) {\n            return this.passingExceptPermissionsValidation(permissions, route, state);\n        }\n        if (this.isParameterAvailable(permissions.only)) {\n            return this.passingOnlyPermissionsValidation(permissions, route, state);\n        }\n        return true;\n    }\n    transformPermission(permissions, route, state) {\n        const only = isFunction(permissions.only)\n            ? permissions.only(route, state)\n            : transformStringToArray(permissions.only);\n        const except = isFunction(permissions.except)\n            ? permissions.except(route, state)\n            : transformStringToArray(permissions.except);\n        const redirectTo = permissions.redirectTo;\n        return {\n            only,\n            except,\n            redirectTo\n        };\n    }\n    isParameterAvailable(permission) {\n        return !!permission && permission.length > 0;\n    }\n    passingExceptPermissionsValidation(permissions, route, state) {\n        if (!!permissions.redirectTo\n            && ((isFunction(permissions.redirectTo))\n                || (isPlainObject(permissions.redirectTo) && !this.isRedirectionWithParameters(permissions.redirectTo)))) {\n            let failedPermission = '';\n            return from(permissions.except)\n                .pipe(mergeMap(permissionsExcept => {\n                return forkJoin([\n                    this.permissionsService.hasPermission(permissionsExcept),\n                    this.rolesService.hasOnlyRoles(permissionsExcept)\n                ]).pipe(tap(hasPermissions => {\n                    const dontHavePermissions = hasPermissions.every(hasPermission => hasPermission === false);\n                    if (!dontHavePermissions) {\n                        failedPermission = permissionsExcept;\n                    }\n                }));\n            }), first(hasPermissions => hasPermissions.some(hasPermission => hasPermission === true), false), mergeMap(isAllFalse => {\n                if (!!failedPermission) {\n                    this.handleRedirectOfFailedPermission(permissions, failedPermission, route, state);\n                    return of(false);\n                }\n                if (!isAllFalse && permissions.only) {\n                    return this.onlyRedirectCheck(permissions, route, state);\n                }\n                return of(!isAllFalse);\n            }))\n                .toPromise();\n        }\n        return Promise.all([\n            this.permissionsService.hasPermission(permissions.except),\n            this.rolesService.hasOnlyRoles(permissions.except)\n        ]).then(([hasPermission, hasRoles]) => {\n            if (hasPermission || hasRoles) {\n                if (permissions.redirectTo) {\n                    this.redirectToAnotherRoute(permissions.redirectTo, route, state);\n                }\n                return false;\n            }\n            if (permissions.only) {\n                return this.checkOnlyPermissions(permissions, route, state);\n            }\n            return true;\n        });\n    }\n    redirectToAnotherRoute(permissionRedirectTo, route, state, failedPermissionName) {\n        const redirectTo = isFunction(permissionRedirectTo)\n            ? permissionRedirectTo(failedPermissionName, route, state)\n            : permissionRedirectTo;\n        if (this.isRedirectionWithParameters(redirectTo)) {\n            redirectTo.navigationCommands = this.transformNavigationCommands(redirectTo.navigationCommands, route, state);\n            redirectTo.navigationExtras = this.transformNavigationExtras(redirectTo.navigationExtras, route, state);\n            this.router.navigate(redirectTo.navigationCommands, redirectTo.navigationExtras);\n            return;\n        }\n        if (Array.isArray(redirectTo)) {\n            this.router.navigate(redirectTo);\n        }\n        else {\n            this.router.navigate([redirectTo]);\n        }\n    }\n    isRedirectionWithParameters(object) {\n        return (isPlainObject(object) && (!!object.navigationCommands || !!object.navigationExtras));\n    }\n    transformNavigationCommands(navigationCommands, route, state) {\n        return isFunction(navigationCommands)\n            ? navigationCommands(route, state)\n            : navigationCommands;\n    }\n    transformNavigationExtras(navigationExtras, route, state) {\n        return isFunction(navigationExtras)\n            ? navigationExtras(route, state)\n            : navigationExtras;\n    }\n    onlyRedirectCheck(permissions, route, state) {\n        let failedPermission = '';\n        return from(permissions.only)\n            .pipe(mergeMap(permissionsOnly => {\n            return forkJoin([\n                this.permissionsService.hasPermission(permissionsOnly),\n                this.rolesService.hasOnlyRoles(permissionsOnly)\n            ]).pipe(tap(hasPermissions => {\n                const failed = hasPermissions.every(hasPermission => hasPermission === false);\n                if (failed) {\n                    failedPermission = permissionsOnly;\n                }\n            }));\n        }), first(hasPermissions => {\n            if (isFunction(permissions.redirectTo)) {\n                return hasPermissions.some(hasPermission => hasPermission === true);\n            }\n            return hasPermissions.every(hasPermission => hasPermission === false);\n        }, false), mergeMap((pass) => {\n            if (isFunction(permissions.redirectTo)) {\n                if (pass) {\n                    return of(true);\n                }\n                else {\n                    this.handleRedirectOfFailedPermission(permissions, failedPermission, route, state);\n                    return of(false);\n                }\n            }\n            else {\n                if (!!failedPermission) {\n                    this.handleRedirectOfFailedPermission(permissions, failedPermission, route, state);\n                }\n                return of(!pass);\n            }\n        }))\n            .toPromise();\n    }\n    handleRedirectOfFailedPermission(permissions, failedPermission, route, state) {\n        if (this.isFailedPermissionPropertyOfRedirectTo(permissions, failedPermission)) {\n            this.redirectToAnotherRoute(permissions.redirectTo[failedPermission], route, state, failedPermission);\n        }\n        else {\n            if (isFunction(permissions.redirectTo)) {\n                this.redirectToAnotherRoute(permissions.redirectTo, route, state, failedPermission);\n            }\n            else {\n                this.redirectToAnotherRoute(permissions.redirectTo[DEFAULT_REDIRECT_KEY], route, state, failedPermission);\n            }\n        }\n    }\n    isFailedPermissionPropertyOfRedirectTo(permissions, failedPermission) {\n        return (!!permissions.redirectTo && permissions.redirectTo[failedPermission]);\n    }\n    checkOnlyPermissions(purePermissions, route, state) {\n        const permissions = Object.assign({}, purePermissions);\n        return Promise.all([\n            this.permissionsService.hasPermission(permissions.only),\n            this.rolesService.hasOnlyRoles(permissions.only)\n        ]).then(([hasPermission, hasRole]) => {\n            if (hasPermission || hasRole) {\n                return true;\n            }\n            if (permissions.redirectTo) {\n                this.redirectToAnotherRoute(permissions.redirectTo, route, state);\n            }\n            return false;\n        });\n    }\n    passingOnlyPermissionsValidation(permissions, route, state) {\n        if ((isFunction(permissions.redirectTo)\n            || isPlainObject(permissions.redirectTo) && !this.isRedirectionWithParameters(permissions.redirectTo))) {\n            return this.onlyRedirectCheck(permissions, route, state);\n        }\n        return this.checkOnlyPermissions(permissions, route, state);\n    }\n}\nNgxPermissionsGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsGuard, deps: [{ token: NgxPermissionsService }, { token: NgxRolesService }, { token: i3.Router }], target: i0.ɵɵFactoryTarget.Injectable });\nNgxPermissionsGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsGuard });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsGuard, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: NgxPermissionsService }, { type: NgxRolesService }, { type: i3.Router }]; } });\n\nclass NgxPermissionsAllowStubDirective {\n    constructor(viewContainer, templateRef) {\n        this.viewContainer = viewContainer;\n        this.templateRef = templateRef;\n        this.permissionsAuthorized = new EventEmitter();\n        this.permissionsUnauthorized = new EventEmitter();\n    }\n    ngOnInit() {\n        this.viewContainer.clear();\n        this.viewContainer.createEmbeddedView(this.getAuthorizedTemplate());\n        this.permissionsUnauthorized.emit();\n    }\n    getAuthorizedTemplate() {\n        return this.ngxPermissionsOnlyThen ||\n            this.ngxPermissionsExceptThen ||\n            this.ngxPermissionsThen ||\n            this.templateRef;\n    }\n}\nNgxPermissionsAllowStubDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsAllowStubDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });\nNgxPermissionsAllowStubDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.0.2\", type: NgxPermissionsAllowStubDirective, selector: \"[ngxPermissionsOnly],[ngxPermissionsExcept]\", inputs: { ngxPermissionsOnly: \"ngxPermissionsOnly\", ngxPermissionsOnlyThen: \"ngxPermissionsOnlyThen\", ngxPermissionsOnlyElse: \"ngxPermissionsOnlyElse\", ngxPermissionsExcept: \"ngxPermissionsExcept\", ngxPermissionsExceptElse: \"ngxPermissionsExceptElse\", ngxPermissionsExceptThen: \"ngxPermissionsExceptThen\", ngxPermissionsThen: \"ngxPermissionsThen\", ngxPermissionsElse: \"ngxPermissionsElse\", ngxPermissionsOnlyAuthorisedStrategy: \"ngxPermissionsOnlyAuthorisedStrategy\", ngxPermissionsOnlyUnauthorisedStrategy: \"ngxPermissionsOnlyUnauthorisedStrategy\", ngxPermissionsExceptUnauthorisedStrategy: \"ngxPermissionsExceptUnauthorisedStrategy\", ngxPermissionsExceptAuthorisedStrategy: \"ngxPermissionsExceptAuthorisedStrategy\", ngxPermissionsUnauthorisedStrategy: \"ngxPermissionsUnauthorisedStrategy\", ngxPermissionsAuthorisedStrategy: \"ngxPermissionsAuthorisedStrategy\" }, outputs: { permissionsAuthorized: \"permissionsAuthorized\", permissionsUnauthorized: \"permissionsUnauthorized\" }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsAllowStubDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxPermissionsOnly],[ngxPermissionsExcept]'\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: i0.TemplateRef }]; }, propDecorators: { ngxPermissionsOnly: [{\n                type: Input\n            }], ngxPermissionsOnlyThen: [{\n                type: Input\n            }], ngxPermissionsOnlyElse: [{\n                type: Input\n            }], ngxPermissionsExcept: [{\n                type: Input\n            }], ngxPermissionsExceptElse: [{\n                type: Input\n            }], ngxPermissionsExceptThen: [{\n                type: Input\n            }], ngxPermissionsThen: [{\n                type: Input\n            }], ngxPermissionsElse: [{\n                type: Input\n            }], ngxPermissionsOnlyAuthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsOnlyUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsExceptUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsExceptAuthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsAuthorisedStrategy: [{\n                type: Input\n            }], permissionsAuthorized: [{\n                type: Output\n            }], permissionsUnauthorized: [{\n                type: Output\n            }] } });\n\nclass NgxPermissionsRestrictStubDirective {\n    constructor(viewContainer) {\n        this.viewContainer = viewContainer;\n        this.permissionsAuthorized = new EventEmitter();\n        this.permissionsUnauthorized = new EventEmitter();\n    }\n    ngOnInit() {\n        this.viewContainer.clear();\n        if (this.getUnAuthorizedTemplate()) {\n            this.viewContainer.createEmbeddedView(this.getUnAuthorizedTemplate());\n        }\n        this.permissionsUnauthorized.emit();\n    }\n    getUnAuthorizedTemplate() {\n        return this.ngxPermissionsOnlyElse ||\n            this.ngxPermissionsExceptElse ||\n            this.ngxPermissionsElse;\n    }\n}\nNgxPermissionsRestrictStubDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsRestrictStubDirective, deps: [{ token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Directive });\nNgxPermissionsRestrictStubDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.0.2\", type: NgxPermissionsRestrictStubDirective, selector: \"[ngxPermissionsOnly],[ngxPermissionsExcept]\", inputs: { ngxPermissionsOnly: \"ngxPermissionsOnly\", ngxPermissionsOnlyThen: \"ngxPermissionsOnlyThen\", ngxPermissionsOnlyElse: \"ngxPermissionsOnlyElse\", ngxPermissionsExcept: \"ngxPermissionsExcept\", ngxPermissionsExceptElse: \"ngxPermissionsExceptElse\", ngxPermissionsExceptThen: \"ngxPermissionsExceptThen\", ngxPermissionsThen: \"ngxPermissionsThen\", ngxPermissionsElse: \"ngxPermissionsElse\", ngxPermissionsOnlyAuthorisedStrategy: \"ngxPermissionsOnlyAuthorisedStrategy\", ngxPermissionsOnlyUnauthorisedStrategy: \"ngxPermissionsOnlyUnauthorisedStrategy\", ngxPermissionsExceptUnauthorisedStrategy: \"ngxPermissionsExceptUnauthorisedStrategy\", ngxPermissionsExceptAuthorisedStrategy: \"ngxPermissionsExceptAuthorisedStrategy\", ngxPermissionsUnauthorisedStrategy: \"ngxPermissionsUnauthorisedStrategy\", ngxPermissionsAuthorisedStrategy: \"ngxPermissionsAuthorisedStrategy\" }, outputs: { permissionsAuthorized: \"permissionsAuthorized\", permissionsUnauthorized: \"permissionsUnauthorized\" }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsRestrictStubDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxPermissionsOnly],[ngxPermissionsExcept]'\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }]; }, propDecorators: { ngxPermissionsOnly: [{\n                type: Input\n            }], ngxPermissionsOnlyThen: [{\n                type: Input\n            }], ngxPermissionsOnlyElse: [{\n                type: Input\n            }], ngxPermissionsExcept: [{\n                type: Input\n            }], ngxPermissionsExceptElse: [{\n                type: Input\n            }], ngxPermissionsExceptThen: [{\n                type: Input\n            }], ngxPermissionsThen: [{\n                type: Input\n            }], ngxPermissionsElse: [{\n                type: Input\n            }], ngxPermissionsOnlyAuthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsOnlyUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsExceptUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsExceptAuthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsAuthorisedStrategy: [{\n                type: Input\n            }], permissionsAuthorized: [{\n                type: Output\n            }], permissionsUnauthorized: [{\n                type: Output\n            }] } });\n\nclass NgxPermissionsModule {\n    static forRoot(config = {}) {\n        return {\n            ngModule: NgxPermissionsModule,\n            providers: [\n                NgxPermissionsStore,\n                NgxRolesStore,\n                NgxPermissionsConfigurationStore,\n                NgxPermissionsService,\n                NgxPermissionsGuard,\n                NgxRolesService,\n                NgxPermissionsConfigurationService,\n                { provide: USE_PERMISSIONS_STORE, useValue: config.permissionsIsolate },\n                { provide: USE_ROLES_STORE, useValue: config.rolesIsolate },\n                { provide: USE_CONFIGURATION_STORE, useValue: config.configurationIsolate },\n            ]\n        };\n    }\n    static forChild(config = {}) {\n        return {\n            ngModule: NgxPermissionsModule,\n            providers: [\n                { provide: USE_PERMISSIONS_STORE, useValue: config.permissionsIsolate },\n                { provide: USE_ROLES_STORE, useValue: config.rolesIsolate },\n                { provide: USE_CONFIGURATION_STORE, useValue: config.configurationIsolate },\n                NgxPermissionsConfigurationService,\n                NgxPermissionsService,\n                NgxRolesService,\n                NgxPermissionsGuard\n            ]\n        };\n    }\n}\nNgxPermissionsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxPermissionsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsModule, declarations: [NgxPermissionsDirective], exports: [NgxPermissionsDirective] });\nNgxPermissionsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsModule, imports: [[]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [],\n                    declarations: [\n                        NgxPermissionsDirective\n                    ],\n                    exports: [\n                        NgxPermissionsDirective\n                    ]\n                }]\n        }] });\nclass NgxPermissionsAllowStubModule {\n}\nNgxPermissionsAllowStubModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsAllowStubModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxPermissionsAllowStubModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsAllowStubModule, declarations: [NgxPermissionsAllowStubDirective], exports: [NgxPermissionsAllowStubDirective] });\nNgxPermissionsAllowStubModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsAllowStubModule, imports: [[]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsAllowStubModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [],\n                    declarations: [\n                        NgxPermissionsAllowStubDirective\n                    ],\n                    exports: [\n                        NgxPermissionsAllowStubDirective\n                    ]\n                }]\n        }] });\nclass NgxPermissionsRestrictStubModule {\n}\nNgxPermissionsRestrictStubModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsRestrictStubModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxPermissionsRestrictStubModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsRestrictStubModule, declarations: [NgxPermissionsRestrictStubDirective], exports: [NgxPermissionsRestrictStubDirective] });\nNgxPermissionsRestrictStubModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsRestrictStubModule, imports: [[]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NgxPermissionsRestrictStubModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [],\n                    declarations: [\n                        NgxPermissionsRestrictStubDirective\n                    ],\n                    exports: [\n                        NgxPermissionsRestrictStubDirective\n                    ]\n                }]\n        }] });\n\n/*\n * Public API Surface of ngx-permissions\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DEFAULT_REDIRECT_KEY, NgxPermissionsAllowStubDirective, NgxPermissionsAllowStubModule, NgxPermissionsConfigurationService, NgxPermissionsConfigurationStore, NgxPermissionsDirective, NgxPermissionsGuard, NgxPermissionsModule, NgxPermissionsPredefinedStrategies, NgxPermissionsRestrictStubDirective, NgxPermissionsRestrictStubModule, NgxPermissionsService, NgxPermissionsStore, NgxRolesService, NgxRolesStore, USE_CONFIGURATION_STORE, USE_PERMISSIONS_STORE, USE_ROLES_STORE };\n"]},"metadata":{},"sourceType":"module"}